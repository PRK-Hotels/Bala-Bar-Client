/* eslint-disable promise/always-return */
import { BrowserWindow, ipcMain, shell } from 'electron';
import moment from 'moment';
import sgMail from '@sendgrid/mail';

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

import {
  ReportInfo,
  VoidReportItems,
  ConsolidatedReportItem,
  KotItemInfo,
  PendingBillInfo,
  ItemWiseReportItem,
} from '../../shared';

import { DBx } from '../db';

sgMail.setApiKey('YOUR_SEND_GRID_KEY');

const reportTemplate = (reportDate: string, htmlBody: string) => ({
  to: 'YOUR_TO_EMAIL', // Change to your recipient
  from: 'YOUR_FROM_EMAIL', // Change to your verified sender
  subject: `Hotel Bala Regency Report - ${reportDate}`,
  text: 'Generated by RG Billing Software.',
  attachments: [
    {
      content: '',
      filename: '',
      type: 'application/pdf',
      disposition: 'attachment',
    },
  ],
  // html: htmlBody,
});

const ReportChannel = () => {
  ipcMain.handle('report_clearance', async (event: any) => {
    try {
      if (DBx) {
        const res = await DBx('report_ref').first();
        const lastDate = res.last_date
          ? moment(res.last_date, 'YYYY-MM-DD').toDate()
          : undefined;
        const reportInfo = ReportInfo(
          res.start_date,
          moment(res.start_date, 'YYYY-MM-DD').toDate(),
          res.cur_report_id,
          res.cur_report_date,
          moment(res.cur_report_date, 'YYYY-MM-DD').toDate(),
          res.last_date,
          lastDate,
          res.count
        );
        const nextReportDay = moment(reportInfo.curReportDateStr, 'YYYY-MM-DD')
          .add(1, 'day')
          .format('YYYY-MM-DD');

        const pendingOrders = await DBx('kot_orders_txn')
          .where('status', 'Pending')
          .andWhere('report_id', reportInfo.curReportId);

        const openOrders = await DBx('kot_open_orders_view')
          .where('cancelled', false)
          .andWhere('voided', false);

        if (
          (pendingOrders && pendingOrders.length > 0) ||
          (openOrders && openOrders.length > 0)
        ) {
          // Has either pending bills or un-billed items
          console.error('Pending bills or Open tables exist');
          return {
            msg: 'Clear Pending bills or Un-billed items.',
          };
        }
        const trx = await DBx.transaction();
        try {
          // Close all pending and open orders
          await trx('kot_orders_txn')
            .whereIn('status', ['Pending', 'Open'])
            .andWhere('report_id', reportInfo.curReportId)
            .update({ closed: true });

          await trx('report_ref')
            .where('id', 1)
            .update({
              cur_report_id: reportInfo.curReportId + 1,
              cur_report_date: nextReportDay,
              last_date: reportInfo.curReportDateStr,
              count: reportInfo.count + 1,
            });

          await trx('report_txn').insert({
            report_date: nextReportDay,
          });

          trx.commit();
          return undefined;
        } catch (e) {
          trx.rollback();
          console.error('Report Transaction Error', e);
          return { msg: 'Report Transaction Error' };
        }
      } else {
        console.log('DBx Not Initialized');
        return { msg: 'DB not Initialized' };
      }
    } catch (err) {
      console.log('Error 2: ', err);
      return { msg: err };
    }
  });

  ipcMain.handle('report_fetch_ref', async (_: any) => {
    try {
      if (DBx) {
        const res = await DBx('report_ref').first();

        const lastDate = res.last_date
          ? moment(res.last_date, 'YYYY-MM-DD').toDate()
          : undefined;
        const reportInfo = ReportInfo(
          res.start_date,
          moment(res.start_date, 'YYYY-MM-DD').toDate(),
          res.cur_report_id,
          res.cur_report_date,
          moment(res.cur_report_date, 'YYYY-MM-DD').toDate(),
          res.last_date,
          lastDate,
          res.count
        );
        console.log('Fetched Report Info');
        return { err: null, report: reportInfo };
      }
      console.log('DBx Not Initialized');
      return { err: 'DB not initialized', report: null };
    } catch (err) {
      console.log('Error 2: ', err);
      return { err, report: null };
    }
  });

  // ipcMain.handle('report_fetch_ref', async (event: any) => {
  //   try {
  //     if (DBx) {
  //       const res = await DBx('report_ref').first();

  //       const lastDate = res.last_date
  //         ? moment(res.last_date, 'YYYY-MM-DD').toDate()
  //         : undefined;
  //       const reportInfo = ReportInfo(
  //         res.start_date,
  //         moment(res.start_date, 'YYYY-MM-DD').toDate(),
  //         res.cur_report_id,
  //         res.cur_report_date,
  //         moment(res.cur_report_date, 'YYYY-MM-DD').toDate(),
  //         res.last_date,
  //         lastDate,
  //         res.count
  //       );
  //       console.log('Fetched Report Info');
  //       return { err: null, report: reportInfo };
  //     }
  //     console.log('DBx Not Initialized');
  //     return { err: 'DB not initialized', report: null };
  //   } catch (err) {
  //     console.log('Error 2: ', err);
  //     return { err, report: null };
  //   }
  // });

  ipcMain.handle(
    'report_fetch_void_report',
    async (event: any, arg: { reportId: number }) => {
      try {
        if (DBx) {
          const res = await DBx('void_report_view').where(
            'report_id',
            arg.reportId
          );
          return res.map((i) =>
            VoidReportItems(
              i.item_name,
              i.item_rate,
              i.item_qty,
              i.table_number,
              i.kot_no,
              i.captain_name
            )
          );
        }
        console.log('DBx Not Initialized');
        return [];
      } catch (err) {
        console.log('Error 2: ', err);
        return [];
      }
    }
  );

  ipcMain.handle(
    'report_consolidated_report',
    async (event: any, arg: { reportId: number }) => {
      try {
        if (DBx) {
          const res = await DBx('consolidated_report_view').where(
            'report_id',
            arg.reportId
          );
          return res.map((i) =>
            ConsolidatedReportItem(
              i.bill_no,
              i.bill_id,
              i.room_no,
              i.payment_type,
              i.bill_total,
              i.grand_total,
              i.total_tax_amount,
              i.pre_discount_food_total,
              i.liquor_amount,
              i.beer_amount,
              i.cgst_amount,
              i.sgst_amount,
              i.taxable_amount,
              i.non_taxable_amount,
              i.discount_amount,
              i.table_number,
              i.order_status,
              i.order_id
            )
          );
        }
        console.log('DBx Not Initialized');
        return [];
      } catch (err) {
        console.log('Error 2: ', err);
        return [];
      }
    }
  );

  ipcMain.handle(
    'report_item_wise_report',
    async (event: any, arg: { reportId: number }) => {
      try {
        if (DBx) {
          const res = await DBx('item_wise_report_view').where(
            'report_id',
            arg.reportId
          );
          return res.map((i) =>
            ItemWiseReportItem(i.item_name, i.quantity, i.category)
          );
        }
        console.log('DBx Not Initialized');
        return [];
      } catch (err) {
        console.log('Error 2: ', err);
        return [];
      }
    }
  );

  ipcMain.handle(
    'report_closed_pending_report',
    async (event: any, arg: { reportId: number }) => {
      try {
        if (DBx) {
          const res = await DBx('closed_pending_view').where(
            'report_id',
            arg.reportId
          );
          const mappedPendingBills = res.map((i) =>
            PendingBillInfo(
              i.bill_id,
              i.bill_no,
              i.captain_name,
              i.table_number,
              i.order_type,
              i.order_id,
              i.bill_total,
              i.grand_total
            )
          );
          return mappedPendingBills || [];
        }
        console.log('DBx Not Initialized');
        return [];
      } catch (err) {
        console.log('Error 2: ', err);
        return [];
      }
    }
  );

  ipcMain.handle(
    'report_closed_open_report',
    async (event: any, arg: { reportId: number }) => {
      try {
        if (DBx) {
          const res = await DBx('closed_open_view').where(
            'report_id',
            arg.reportId
          );
          const mappedOrderItems = res.map((i) => KotItemInfo(i));
          return mappedOrderItems || [];
        }
        console.log('DBx Not Initialized');
        return [];
      } catch (err) {
        console.log('Error 2: ', err);
        return [];
      }
    }
  );

  ipcMain.handle(
    'report_to_pdf',
    async (event: any, arg: { fileName: string }) => {
      try {
        const pdfPath = path.join(
          os.tmpdir(),
          `${arg.fileName || 'undefined'}.pdf`
        );
        const win = BrowserWindow.fromWebContents(event.sender);

        const data = await win?.webContents.printToPDF({});
        if (data === undefined) {
          return 'Unable to generate the report!';
        }
        fs.writeFileSync(pdfPath, data);
        shell.openExternal(`file://${pdfPath}`);
        return '';
        // event.sender.send('wrote-pdf', pdfPath);
        // return '';
        // });
      } catch (err) {
        console.log(err);
        return err;
      }
    }
  );

  ipcMain.handle(
    'email_pdf_report',
    async (event: any, arg: { fileName: string; type: string }) => {
      try {
        const win = BrowserWindow.fromWebContents(event.sender);
        const data = await win?.webContents.printToPDF({});

        if (data === undefined) {
          return { err: 'Failed to generate the report!' };
        }

        const attachment = data.toString('base64');
        const msg = reportTemplate(arg.fileName, '');
        msg.attachments = [
          {
            content: attachment,
            filename: arg.fileName,
            type: 'application/pdf',
            disposition: 'attachment',
          },
        ];

        await sgMail.send(msg);

        switch (arg.type) {
          case 'void':
            event.sender.send('emailed-void-pdf');
            break;

          case 'cashier':
            event.sender.send('emailed-cashier-pdf');
            break;

          case 'paymode':
            event.sender.send('emailed-paymode-pdf');
            break;

          default:
            console.log('Mailed Unkown Report Type');
        }
        return '';
      } catch (err: any) {
        console.log(err);
        return { msg: 'Unknown Error' };
      }
    }
  );

  ipcMain.on(
    'report_email_all',
    async (event: any, arg: { reportId: number; reportDate: Date }) => {
      try {
        if (DBx) {
          DBx('consolidated_report_view')
            .where('report_id', arg.reportId)
            .then((res) => {
              const reportRes = res.map((i) =>
                ConsolidatedReportItem(
                  i.bill_no,
                  i.bill_id,
                  i.room_no,
                  i.payment_type,
                  i.bill_total,
                  i.grand_total,
                  i.total_tax_amount,
                  i.pre_discount_food_total,
                  i.liquor_amount,
                  i.beer_amount,
                  i.cgst_amount,
                  i.sgst_amount,
                  i.taxable_amount,
                  i.non_taxable_amount,
                  i.discount_amount,
                  i.table_number,
                  i.order_status,
                  i.order_id
                )
              );

              const reportBody = `<div>
                                    <table width="100%" cellpadding="0" cellspacing="0" style="min-width:100%;">
                                        <thead>
                                            <tr>
                                                <th scope="col" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;line-height:30px">Table No</th>
                                                <th scope="col" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;line-height:30px">Captain</th>
                                                <th scope="col" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;line-height:30px">Kot No</th>
                                                <th scope="col" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;line-height:30px">Item Name</th>
                                                <th scope="col" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;line-height:30px">Qty</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                        ${reportRes
                                          .map((i) => {
                                            return `<tr>
                                     <td valign="top" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;">${i.tableNumber}</td>
                                     <td valign="top" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;">${i.paymentType}</td>
                                     <td valign="top" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;">${i.orderStatus}</td>
                                     <td valign="top" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;">${i.billTotal}</td>
                                     <td valign="top" style="padding:5px; font-family: Arial,sans-serif; font-size: 16px; line-height:20px;">${i.totalTaxAmount}</td>
                            </tr>`;
                                          })
                                          .join('')}
                                        </tbody>
                                    </table>
                            </div>`;

              const reportEmail = reportTemplate(
                arg.reportDate.toDateString(),
                reportBody
              );

              sgMail
                .send(reportEmail)
                .then(() => {
                  console.log('Email sent');
                  event.returnValue = undefined;
                })
                .catch((emailErr: any) => {
                  console.error(emailErr);
                  event.returnValue = { msg: emailErr };
                });
            })
            .catch((e) => {
              console.log('Void Report DB Error', e);
              event.returnValue = { msg: 'Void Report DB Error' };
            });
        } else {
          console.log('DBx Not Initialized');
          event.returnValue = { msg: 'DBx Not Initialized' };
        }
      } catch (err) {
        event.returnValue = { msg: 'Error 2' };
        console.log('Error 2: ', err);
      }
    }
  );
};

export default ReportChannel;
